#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "comm_protocol.h"

char *test_data[] = {
    // =============================================================================
    // 正常有效数据包测试用例（基础测试）
    // =============================================================================
    "@0107100FAA31F4*6B",           // 标准完整包
    "@020855AABBCCDD*60",           // 中等长度包
    "@0000*6A",                     // 最小包（无载荷）
    "@01011F*1D",                   // 单字节载荷包
    
    // =============================================================================
    // 粘包测试用例（多包连续接收）
    // =============================================================================
    "@0107100FAA31F4*6B@020855AABBCCDD*60",                      // 标准粘包：两个完整包
    "@0000*6A@01011F*1D@020855AABBCCDD*60",                      // 三包粘连
    "@0107100FAA31F4*6B@0000*6A@01011F*1D@020855AABBCCDD*60",    // 四包粘连
    "@A10312345678*11@B1020001*1A@C0021234*1F@FE020000*6B",     // 不同长度多包粘连
    
    // =============================================================================
    // 分包测试用例（一个完整包被拆分成多次接收）
    // =============================================================================
    // 注意：这里用特殊标记表示分包，实际测试时需要分多次调用解析函数
    "@0107100F",            // 包的前半部分
    "AA31F4*6B",            // 包的后半部分
    
    "@0208",                // 三段分包 - 第一段
    "55AABBCC",             // 三段分包 - 第二段  
    "DD*60",                // 三段分包 - 第三段
    
    "@",                    // 极限分包 - 只有头
    "0000*6A",              // 极限分包 - 其余部分
    
    "@0107100FAA31F4*",     // 分包 - 差校验位
    "6B",                   // 分包 - 只有校验位
    
    // =============================================================================
    // 混合情况：分包+粘包
    // =============================================================================
    "@0107100F",                           // 第一个包的前半部分
    "AA31F4*6B@020855AABBCCDD*60",         // 第一个包后半部分+完整第二包
    
    "@0107100FAA31F4*6B@020855",           // 完整第一包+第二包前半部分（修正为偶数长度）
    "AABBCCDD*60",                         // 第二包后半部分（修正）
    
    "@0000*6A@0101",                       // 完整包+半包
    "1F*1D@020855AABBCCDD*60",             // 半包完成+新完整包
    
    "@A103",                               // 第一个半包
    "12345678*11@B102",                    // 第一包完成+第二包开始
    "0001*1A",                             // 第二包完成
    
    // =============================================================================
    // 带干扰数据的测试用例
    // =============================================================================
    "FF00@0107100FAA31F4*6B",                      // 前缀干扰数据
    "@0107100FAA31F4*6BEE11",                      // 后缀干扰数据  
    "AA55@0107100FAA31F4*6B1122@020855AABBCCDD*60", // 前缀干扰+粘包
    
    // =============================================================================
    // 错误包+正常包混合测试
    // =============================================================================
    "@0107100GAA31F4*6B@020855AABBCCDD*60",        // 第一包有非法字符G，第二包正常
    "@0107100FAA31F4*XX@020855AABBCCDD*60",        // 第一包校验错误，第二包正常
    "@0107100FAA31F4@020855AABBCCDD*60",           // 第一包缺少*，第二包正常
    
    // =============================================================================
    // 边界条件测试
    // =============================================================================
    "@@0107100FAA31F4*6B",                         // 双起始符
    "@0107100FAA31F4**6B",                         // 双结束符
    "@0107@100FAA31F4*6B",                         // 数据中包含@
    "@0107*100FAA31F4*6B",                         // 数据中包含*
    
    // =============================================================================
    // 空数据和单字符测试
    // =============================================================================
    "",                                             // 空字符串
    "@",                                           // 只有起始符
    "*",                                           // 只有结束符
    "6B",                                          // 只有校验位
    
    // =============================================================================
    // 长数据包测试
    // =============================================================================
    "@102000112233445566778899A0AABBCCDDEEFF1023456789ABCDEF*1E", // 长包
    
    // =============================================================================  
    // 奇数长度测试用例（用于测试错误处理）
    // =============================================================================
    "@1020001122334455667788990AABBCCDDEEFF1023456789ABCDEF*5F", // 原始奇数长度长包（53字符）- 应该解析失败
    
    NULL  // 结束标记
};

void protocol_decode_cb(void *user_data, uint8_t *payload, uint16_t payload_len)
{
    protocol_encoder_t encoder;
    uint8_t ret = 0;
    comm_protocol_encoder_init(&encoder);
    ret = comm_protocol_encode(&encoder, payload, payload_len);
    if(ret == RESULT_OK)
    {
        printf("Encoded Data: \n");
        for (uint16_t i = 0; i < encoder.data_len; i++) 
        {
            printf("%02X ", (unsigned)encoder.data[i]);
        }
        printf("\n");
    }

}

int main(int argc, char *argv[])
{
    protocol_decoder_t decoder;
    comm_protocol_decoder_init(&decoder);
    comm_protocol_decoder_set_callback(&decoder, protocol_decode_cb, NULL);
    for (char **p = test_data; *p != NULL; ++p) {
        printf("\n\n\n");
        printf("Processing Test Data: %s\n", *p);
        comm_protocol_decoder_process(&decoder, (uint8_t*)*p, strlen(*p));
        printf("=============================================================\n\n\n");
    }
}